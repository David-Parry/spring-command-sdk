/*
 * Copyright (C) 2025 Qodo
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 */

package ai.qodo.command.internal.util;

import ai.qodo.command.internal.api.TaskResponse;
import ai.qodo.command.internal.pojo.CommandSession;
import ai.qodo.command.internal.pojo.CommandSessionBuilder;
import ai.qodo.command.internal.pojo.ServerRawResponses;
import ai.qodo.command.internal.pojo.WebSocketIds;

import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.UUID;

import static ai.qodo.command.internal.service.WebSocketNotificationService.TYPE_STRUCTURED_OUTPUT;

public class WebSocketUtil {
    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern("yyyyMMdd");

    /**
     * Generates all parameters for a NEW session (no checkpoint).
     *
     * @return ConnectionParams with session_id and request_id (no checkpoint_id)
     */
    public static WebSocketIds generateNewWebSocketIds() {
        String sessionId = generateSessionId();
        String requestId = generateRequestId();
        String checkpointId = generateCheckpointId();
        return new WebSocketIds(sessionId, requestId, checkpointId);
    }


    /**
     * Generates a partition-compatible session ID.
     * Format: YYYYMMDD_UUID
     * Example: 20241203_a7b8c9d0-1234-5678-9abc-def012345678
     * <p>
     * This format ensures compatibility with PostgreSQL RANGE partitioning.
     */
    private static String generateSessionId() {
        LocalDateTime utcNow = LocalDateTime.now(ZoneOffset.UTC);
        String datePrefix = utcNow.format(DATE_FORMAT);
        String uuidSuffix = UUID.randomUUID().toString();

        return datePrefix + "_" + uuidSuffix;
    }

    /**
     * Generates a request ID for tracking individual requests.
     * Format: req_TIMESTAMP_UUID
     * Example: req_20241203145230123_a1b2c3d4
     * <p>
     * The backend accepts any string for request_id, but this format
     * provides good traceability and uniqueness.
     */
    private static String generateRequestId() {
        return UUID.randomUUID().toString();
    }

    /**
     * Generates a checkpoint ID (typically done by the backend).
     * Format: Standard UUID v4
     * Example: 1ef4b2a0-8b9a-4c5d-9e6f-7a8b9c0d1e2f
     * <p>
     * Note: Checkpoint IDs are usually generated by LangGraph on the backend.
     * This method is for testing or special cases where you need to generate one.
     */
    public static String generateCheckpointId() {
        // LangGraph uses UUID v4 for checkpoint IDs
        return UUID.randomUUID().toString();
    }


    public static ServerRawResponses parseTaskResponses(List<TaskResponse> response) {
        StringBuilder structuredJson = new StringBuilder();
        StringBuilder unstructuredJson = new StringBuilder();
        
        if (response != null) {
            for (TaskResponse r : response) {
                StringBuilder target = TYPE_STRUCTURED_OUTPUT.equalsIgnoreCase(r.type()) 
                    ? structuredJson 
                    : unstructuredJson;
                appendToolArgs(r, target);
            }
        }
        
        return new ServerRawResponses(structuredJson.toString(), unstructuredJson.toString());
    }
    
    private static void appendToolArgs(TaskResponse response, StringBuilder target) {
        if (response.data() != null && response.data().toolArgs() != null) {
            response.data().toolArgs().values().forEach(target::append);
        }
    }

}
