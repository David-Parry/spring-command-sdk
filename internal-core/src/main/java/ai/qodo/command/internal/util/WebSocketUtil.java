/*
 * Copyright (C) 2025 Qodo
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 */

package ai.qodo.command.internal.util;

import ai.qodo.command.internal.pojo.CommandSession;
import ai.qodo.command.internal.pojo.CommandSessionBuilder;
import ai.qodo.command.internal.pojo.WebSocketIds;

import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.UUID;

public class WebSocketUtil {
    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern("yyyyMMdd");
    private static final DateTimeFormatter TIMESTAMP_FORMAT = DateTimeFormatter.ofPattern("yyyyMMddHHmmssSSS");

    /**
     * Generates all parameters for a NEW session (no checkpoint).
     *
     * @return ConnectionParams with session_id and request_id (no checkpoint_id)
     */
    public static WebSocketIds generateNewWebSocketIds() {
        String sessionId = generateSessionId();
        String requestId = generateRequestId();
        String checkpointId = generateCheckpointId();
        return new WebSocketIds(sessionId, requestId, checkpointId);
    }


    /**
     * Generates a partition-compatible session ID.
     * Format: YYYYMMDD_UUID
     * Example: 20241203_a7b8c9d0-1234-5678-9abc-def012345678
     * <p>
     * This format ensures compatibility with PostgreSQL RANGE partitioning.
     */
    private static String generateSessionId() {
        LocalDateTime utcNow = LocalDateTime.now(ZoneOffset.UTC);
        String datePrefix = utcNow.format(DATE_FORMAT);
        String uuidSuffix = UUID.randomUUID().toString();

        return datePrefix + "_" + uuidSuffix;
    }

    /**
     * Generates a request ID for tracking individual requests.
     * Format: req_TIMESTAMP_UUID
     * Example: req_20241203145230123_a1b2c3d4
     * <p>
     * The backend accepts any string for request_id, but this format
     * provides good traceability and uniqueness.
     */
    private static String generateRequestId() {
//        LocalDateTime utcNow = LocalDateTime.now(ZoneOffset.UTC);
//        String timestamp = utcNow.format(TIMESTAMP_FORMAT);
//        String shortUuid = UUID.randomUUID().toString().substring(0, 8);
//
//        return "req_" + timestamp + "_" + shortUuid;
        return UUID.randomUUID().toString();
    }

    /**
     * Generates a checkpoint ID (typically done by the backend).
     * Format: Standard UUID v4
     * Example: 1ef4b2a0-8b9a-4c5d-9e6f-7a8b9c0d1e2f
     * <p>
     * Note: Checkpoint IDs are usually generated by LangGraph on the backend.
     * This method is for testing or special cases where you need to generate one.
     */
    public static String generateCheckpointId() {
        // LangGraph uses UUID v4 for checkpoint IDs
        return UUID.randomUUID().toString();
    }

    /**
     * Ensures a session ID is partition-compatible.
     */
    private static String ensurePartitionCompatible(String sessionId) {
        // Check if already in correct format (YYYYMMDD_UUID)
        if (sessionId != null && sessionId.matches("^\\d{8}_[a-f0-9-]{36}$")) {
            return sessionId;
        }

        // Convert to partition-compatible format
        LocalDateTime utcNow = LocalDateTime.now(ZoneOffset.UTC);
        String datePrefix = utcNow.format(DATE_FORMAT);

        // If it's a UUID, prefix it
        if (sessionId != null && sessionId.matches("^[a-f0-9-]{36}$")) {
            return datePrefix + "_" + sessionId;
        }

        // Otherwise, generate a new one
        return generateSessionId();
    }


}
